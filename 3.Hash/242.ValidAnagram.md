[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/description/)


![Difficulty](https://img.shields.io/badge/Difficulty-Easy-brightgreen)
![Tag](https://img.shields.io/badge/Tag-Hash%20Table-lightgrey)


---

## ðŸ“ Description

> Given two strings s and t, return true if t is an anagram of s, and false otherwise.

## ðŸ“šSimilar Questions
242.ValidAnagram, [383.RansomNote](383.RansomNote.md)

---

## ðŸ’¡ Solution

### Logic 
1. Sort 

2. Array (**Efficient!**)


---

## ðŸ” Code

### Version 1 - Array Sort

- Timeï¼š$O(n\log{n} + m\log m)$
  - Sort takes $O(n\log{n} + m\log m)$
  - The comparison `==` takes $O(min(n, m))$
- Spaceï¼š$O(n+m)$
```python
def isAnagram(s: str, t: str) -> bool:
    return sorted(s) == sorted(t)
```

### Version 2 - Array Letter
- Time: $O(n+m)$
  - O(n) for adding s to record
  - O(m) for deleting t from record
- Space: O(1)
  - record is a fixed-size array of 26 integers â†’ O(1)

æ•°ç»„å…¶å®žå°±æ˜¯ä¸€ä¸ªç®€å•å“ˆå¸Œè¡¨
```python
def isAnagram(s: str, t: str) -> bool:
    record = [0] * 26
    for char in s:
        record[ord(char) - ord('a')] += 1
    for char in t:
        idx = ord(char) - ord('a')
        record[idx] -= 1
        if record[idx] < 0:
            return False
    return all(cnt == 0 for cnt in record)
```


### Version 3 - Map - Python Counter
- Time: O(n+m)
  - Build Counters: O(n) + O(m)
  - Comparing two dictionaries: O(1) since worst-case compares all keys and values â†’ O(k), where k is the number of unique characters ($k\leq26$).
- Space: O(1)
  - Counter(s) creates a dictionary of at most 26 keys â†’ O(1) (constant space, bounded by character set)
```python
def isAnagram(s: str, t: str) -> bool:
    from collections import Counter
    return Counter(s) == Counter(t)
```
