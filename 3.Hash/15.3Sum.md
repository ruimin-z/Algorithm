# [15. 3Sum](https://leetcode.com/problems/3sum/description/)


![Difficulty](https://img.shields.io/badge/Difficulty-Medium-orange)
![Tag](https://img.shields.io/badge/Tag-Hash%20Table-lightgrey)
![Tag](https://img.shields.io/badge/Tag-Two%20Pointers-lightgrey)


---

## ğŸ“ Description

> Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
>
> 0 <= a, b, c, d < n
>
> a, b, c, and d are distinct.
> 
> nums[a] + nums[b] + nums[c] + nums[d] == target
>
> You may return the answer in any order.


## ğŸ“šSimilar Questions
[1.TwoSum](1.TwoSum.md), 15.3Sum, [18.4Sum](18.4Sum.md), [454.4SumII](454.4SumII.md)

---

## ğŸ’¡ Solution

### Logic 

éš¾ç‚¹åœ¨å‰ªæå’Œå»é‡ã€‚

- Different from [1.TwoSum](./1.TwoSum.md) and [454.4SumII](./454.4SumII.md), the input is only one array
- Need to remove duplicates 

1. Brute Force - three nested for loops $O(n^3)$

2. Use Hash Set ï¼ˆå“ˆå¸Œæ³•å¾ˆå¤æ‚å› ä¸ºéœ€è¦å»é‡ï¼ï¼‰

3. Two Pointers (å› ä¸ºè¿”å›çš„ä¸æ˜¯ä¸‹æ ‡indexï¼Œå¦‚æœè¿”å›ä¸‹æ ‡å°±ä¸èƒ½ç”¨åŒæŒ‡é’ˆï¼Œå› ä¸ºåŒæŒ‡é’ˆéœ€è¦æ’åºï¼Œindexä¼šä¹±)
   - Need sort

 
### Complexity Analysis

- Timeï¼š`O(n^2)`
  - sort is O(nlogn)
  - for loop (idx i) + while loop (idx left and right): O(n^2)
- Spaceï¼š`O(1)`

> Why? æ»¡è¶³æ¡ä»¶çš„ä¸‰å…ƒç»„ä¸ºå¸¸æ•°ä¸ªï¼Œä¸éšnè€Œå˜åŒ–ã€‚resultå­˜æ”¾ä¸´æ—¶ç»“æœã€‚

---
## ğŸ” Code

### Version 1 - Hash Set
```python

```


### Version 2 - Two Pointers
![](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

```python
def threeSum(self, nums: list[int]) -> list[list[int]]:
     nums.sort()
     result = []
     
     for curr in range(len(nums)):
         if nums[curr] > 0: 
             return result
         if curr > 0 and nums[curr] == nums[curr-1]: 
             continue
         left = curr+1
         right = len(nums)-1
         while left < right:
             total = nums[curr]+nums[left]+nums[right]
             if total < 0:
                 left += 1
             elif total > 0:
                 right -= 1
             else:
                 result.append([nums[curr], nums[left], nums[right]])
                 while left < right and nums[left] == nums[left+1]: 
                     left += 1
                 while left < right and nums[right] == nums[right-1]: 
                     right -= 1
                 right -= 1
                 left += 1
     return result
```
1. sort required

2. å¯ä»¥`for curr in range(len(nums)):` ä¹Ÿå¯ä»¥ `range(len(nums)-2)`
3. å»é‡å’Œå‰ªæ
   - (pruningå‰ªæ) if current num > 0, no need to go further å½“å‰æ•°å­—å·²ç»å¤§äº0ï¼Œåˆ™åç»­ä¸å¯èƒ½æœ‰å’Œä¸ºé›¶çš„ä¸‰å…ƒç»„ï¼Œè¿”å›result
   - (deduplicatingå»é‡) if current num is same as last num, continue å½“å‰æ•°å­—å’Œä¸Šä¸€ä¸ªæ•°å­—ç›¸ç­‰ï¼Œè·³è¿‡
   - å½“æ‰¾åˆ°ä¸‰å…ƒç»„æ—¶ï¼š
     - å…ˆæ”¶è·ç»“æœï¼Œä¹‹åå†å¤„ç†å»é‡é€»è¾‘
     - (deduplicatingå»é‡) whileå·¦è¾¹æœ‰é‡å¤ï¼ŒæŒç»­æ›´æ–°å·¦è¾¹ä¸‹æ ‡ï¼›whileå³è¾¹æœ‰é‡å¤ï¼ŒæŒç»­æ›´æ–°å³è¾¹ä¸‹æ ‡
       - é˜²æ­¢OOB: è¦æ±‚ left < right (<, not <= because of the following bullet point)
     - ä¸ç®¡æœ‰æ²¡æœ‰é‡å¤ï¼Œéƒ½è¦æœ€åå†æ›´æ–°ä¸€æ¬¡leftå’Œright

