# [349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/)


![Difficulty](https://img.shields.io/badge/Difficulty-Easy-brightgreen)
![Tag](https://img.shields.io/badge/Tag-Hash%20Table-yellow)

---
## ðŸ“ Description

> Given two integer arrays nums1 and nums2, return an array of their . Each element in the result must be unique and you may return the result in any order.


---

## ðŸ’¡ Solution

Logic: Hash


---

## ðŸ” Code


### Version 1 (Not Preferrable)
```python
def intersection(self, nums1, nums2) -> list:
    s = set(nums1 + nums2)
    res = []
    for v in s:
        if v in nums1 and v in nums2:
            res.append(v)
    return res
```
`if` statement takes O(n+m). Inside `for loop`, it has worst case $O((n+m)^2)$ time complexity. 
Very expensive.


### Version 2 - Hash Set
- Time: O(n + m)
  - O(n) for building set(nums1)
  - O(m) for traversing nums2
    - O(1) for lookup, O(1) for add to set
- Space: O(n + k)
  - set `s` has length worst case $n$
  - set `res` build needs O(k) ($k \leq min\{n, m\}$)
  - return `list(res)` ä¼šé¢å¤–å¤åˆ¶ O(k) ç©ºé—´

```python
def intersection(self, nums1, nums2) -> list:
    s = set(nums1)
    res = set()
    for v in nums2:
        if v in s:
            res.add(v)
    return list(res)
```

To avoid expensive iteration in array, put iteration `all values in nums2` in `for loop.`

To avoid duplication of elements, use `set` for result then convert to `list`.


### Version 2 - Hash Map + Hash Set
- Time: O(n + m)
  - for num in nums1: O(n) æž„å»º collection å­—å…¸ï¼Œæ‰§è¡Œ n æ¬¡æ’å…¥
  - for num in nums2: O(m) å¯¹æ¯ä¸ªå…ƒç´ åšå“ˆå¸ŒæŸ¥æ‰¾å¹¶å¯èƒ½åˆ é™¤é”®ï¼ˆå¹³å‡éƒ½æ˜¯ O(1)ï¼‰
- Space: O(n + k)
  - dictå“ˆå¸Œè¡¨ï¼Œæœ€å¤šå­˜å‚¨ nums1 ä¸­çš„æ‰€æœ‰å”¯ä¸€å…ƒç´ ï¼šO(n)
  - res æž„å»ºéœ€è¦ O(k) ($k \leq min\{n, m\}$)
```python
def intersection(self, nums1, nums2) -> list:
    collection = {}
    for num in nums1:
        collection[num] = collection.get(num, 0) + 1
    res = []
    for num in nums2:
        if num in collection: # O(1) avg due to hash 
            res.append(num)
            del collection[num]
    return res
```
- `del collection[key]` removes the entry (both key and value)

