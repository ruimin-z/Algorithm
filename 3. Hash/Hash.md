# Hash哈希


## 为什么哈希结构？

存放之前遍历过的元素，判断元素是否遍历过

## 用什么样的哈希映射？

判断一个元素 - 用HashSet

判断两个元素 - 用HashMap


## 哈希机制

| 操作类型         | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度  | 说明                                               |
|------------------|----------------|----------------|-------------|----------------------------------------------------|
| 查询 (lookup)    | O(1)           | O(n)           | O(1)        | 哈希值定位 + 比较；最坏情况是大量冲突              |
| 插入 (insert)    | O(1)           | O(n)           | O(n)        | 包括动态扩容空间；最坏 rehash 时耗时大              |
| 删除 (delete)    | O(1)           | O(n)           | O(1)        | 同样依赖哈希冲突情况                                |
| 遍历 (iterate)   | O(n)           | O(n)           | O(1)        | 无序结构遍历是线性的；Python 3.6+ 维持插入顺序       |

- Advantages:

- Disadvantages:
  - Unsorted - 可以用Treemap来保存order


### 查询为什么是average O(1)?

哈希表（Hash Table）通过哈希函数把 key 映射到数组中的索引位置（槽位）：

```
key → hash(key) → index → value
```     

查询流程：
1. 计算哈希值：hash(key)（时间复杂度 O(1)）
2. 取模获得数组下标：hash(key) % capacity（时间复杂度 O(1)）
3. 直接访问该数组槽位（O(1)）

由于所有这些操作都是固定时间的计算 + 数组下标访问，所以在哈希分布良好、冲突较少的情况下，平均查询时间就是 O(1)。

### 查询最坏情况为什么是 O(n)？

当所有 key 都被哈希到同一个槽（极端哈希冲突）时，哈希表会退化成一个线性列表（开放寻址） 或者链表（链地址法）

那么查找就要线性扫描，变成 O(n)。

这在哈希函数设计差或被恶意构造输入的情况下可能发生。



## 字典
Python 字典是通过 哈希表 实现的。
Python 中 `dict` 的底层机制：**开放寻址 + 动态扩容 + 版本标记优化**

### Python哈希底层机制
1. 开放寻址（Open Addressing）
- 元素直接存储在哈希表的数组中，每个 key-value 占一个“槽位”（slot）。
- 如果多个 key 的哈希值相同（哈希冲突），就寻找下一个空槽位。
- Python 使用的是一种 “探测（probing）”策略，不是单纯线性探测，而是更复杂的形式，性能更稳。

2. 动态扩容（Dynamic Resizing）
- Python dict 的`负载因子`大概在 $\frac{2}{3}$ ~ 0.75，超过就扩容（通常扩容为原来的 2 倍）。
- 扩容是为了降低哈希冲突率，保持 O(1) 操作时间。
- 扩容会导致 `rehashing`，即重新计算所有 key 的哈希值并插入新表。

> ⚠️ **Warning:** 扩容可能带来短时性能下降（O(n)），但整体 amortized cost 是 O(1)。

3. 版本标记优化（version tag）

Python 使用 version tag 来优化一些操作，比如：
    如果你多次遍历同一个 dict（比如在 for k in d: 中），
Python 可以通过一个 version 值快速判断 dict 是否改变，从而避免重复构造迭代器。

特别适用于 全局变量查找（global name lookup），速度快很多。这是一种`cache optimization`缓存优化，提升解释器性能。


### 不同操作复杂度
1. `del dict[key]` 的时间复杂度
- 平均时间复杂度： O(1)
- 最坏时间复杂度： O(n)

del 操作的平均复杂度是常数时间 O(1)，因为它直接根据哈希值找到对应的桶并删除。
但在极端情况下（如哈希冲突很多，或触发 rehashing），可能退化为 O(n)，不过这种情况在实际中非常少见。

  
2. `key in dict` 的时间复杂度
- 平均时间复杂度： O(1)
- 最坏时间复杂度： O(n)

`x in dict` 实际上是检查 `dict.__contains__(x)`，即是否有这个 key。
Python 会计算 `x.__hash__()`，然后查找对应的哈希桶。
如果哈希冲突少（大部分情况），操作是 O(1)。
如果冲突很多，可能要线性扫描冲突链或桶序列，最坏是 O(n)，但几乎不会发生（Python 会自动调整哈希表大小）。





